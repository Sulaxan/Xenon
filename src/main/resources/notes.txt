@Command("test") // Optional; not required if class implements Command<?>
@CallDefaultOnInvalidSubCommand
public class TestCommand implements Command<SomeSender>, Permissable<SomeSender> {

    // Optional constructor
    public TestCommand() {

    }

    // In all cases, CommandSender can be SomeSender

    @LimitArgs(max = 5)
    @Override
    public void onCommand(CommandSender sender, String[] args) {

    }

    // Flag; true = continue running command, false = don't continue running command
    @Flag(name = "-h", args = 1)
    public boolean helpFlag(CommandSender sender) {
        return true;
    }

    // Raw args required
    @SubCommand("Test")
    public void test(CommandSender sender, String[] args) {

    }

    // No args required
    @SubCommand(name = "Test2", description = "Test", usage = "")
    public void test(CommandSender sender) {

    }

    // Primitive casting args
    // args at the end is left over
    @SubCommand("Test3")
    @DefaultValueIfUnparsable
    @LimitArgs(min = 1, max = 2)
    public void test(CommandSender sender, @DefaultInt(1) int param1, int param2, @DefaultDouble(1.0d) double param3, String[] args) {

    }

    @Override
    public boolean hasPermission(CommandSender sender, String[] args) {
        return true;
    }

    @SubCommandPermissionCheck("some sub command")
    public boolean hasPerms(CommandSender sender) {
        return true;
    }

    // In the case you want to have more than 1 command per class
    // Note: method must have this format
    @Command("name") // same @Command as used for a class
    public void someCommand(CommandSender sender, String[] args) {
    }
}

// Registering command
parser.register(new TestCommand())
    .alwaysConstructNewInstance() // default will use same instance
    .constructorParams(Object...)
    OR
    .constructorParams(() -> { return new Object[] {} })
    ;

parser.newCommandBuilder()
    .command("name", (sender, args) -> {})
    .usage("")
    .description("")
    .flag("-h", sender -> true) // name, args
    .flag("-h2", 1, sender -> true) // name, args, callable
    .subCommand("Test", (sender, args) -> {})
    .callDefaultOnInvalidSubCommand()
    .build();